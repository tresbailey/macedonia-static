{"version":3,"sources":["ScrollWatch-1.1.0.min.js"],"names":["root","factory","define","amd","exports","module","ScrollWatch","this","instanceId","instanceData","ignoreClass","config","container","window","document","documentElement","watch","watchOnce","inViewClass","debounce","debounceTriggerLeading","scrollDebounce","resizeDebounce","scrollThrottle","resizeThrottle","watchOffset","infiniteScroll","infiniteOffset","onElementInView","onElementOutOfView","onInfiniteXInView","onInfiniteYInView","initEvent","extend","retObj","i","key","obj","len","arguments","length","hasOwnProperty","throttle","fn","threshhold","scope","last","deferTimer","context","now","Date","args","clearTimeout","setTimeout","apply","func","wait","immediate","timeout","timestamp","result","later","getTime","callNow","saveContainerElement","isContainerWindow","call","_id","querySelector","saveElements","elements","Array","prototype","slice","querySelectorAll","saveScrollPosition","lastScrollPosition","getScrollPosition","checkViewport","eventType","checkElements","checkInfinite","el","data","responseData","direction","getScrolledDirection","getScrolledAxis","isElementInView","classList","contains","add","splice","remove","axis","viewableRange","scrollSize","callback","isInfiniteScrollPaused","getViewableRange","scrollWidth","scrollHeight","hasScrollPositionChanged","end","addListeners","scrollingElement","getScrollingElement","addEventListener","scrollHandler","resizeHandler","removeListeners","removeEventListener","getViewportSize","size","w","clientWidth","h","clientHeight","pos","left","pageXOffset","top","pageYOffset","scrollLeft","scrollTop","range","x","y","scrollPos","viewportSize","start","getElementRange","containerCoords","coords","getBoundingClientRect","right","bottom","width","height","scrollDir","position","curScrollPosition","elRange","offset","isElementInVerticalView","isElementInHorizontalView","mergeOptions","opts","handler","e","type","Object","defineProperty","value","bind","refresh","destroy","pauseInfiniteScroll","resumeInfiniteScroll"],"mappings":"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","file":"ScrollWatch-1.1.0.min.js","sourcesContent":["(function(root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define([], factory);\n  } else if (typeof exports === 'object') {\n    module.exports = factory();\n  } else {\n    root.ScrollWatch = factory();\n  }\n}(this, function() {\n'use strict';\n\n// Give each instance on the page a unique ID.\nvar instanceId = 0;\n\n// Store instance data privately so it can't be accessed/modified.\nvar instanceData = {};\n\nvar ignoreClass = 'scroll-watch-ignore';\n\nvar config = {\n\t// The default container is window, but we need the actual\n\t// documentElement to determine positioning.\n\tcontainer: window.document.documentElement,\n\twatch: '[data-scroll-watch]',\n\twatchOnce: true,\n\tinViewClass: 'scroll-watch-in-view',\n\tdebounce: false,\n\tdebounceTriggerLeading: false,\n\tscrollDebounce: 250,\n\tresizeDebounce: 250,\n\tscrollThrottle: 250,\n\tresizeThrottle: 250,\n\twatchOffset: 0,\n\tinfiniteScroll: false,\n\tinfiniteOffset: 0,\n\tonElementInView: function(){},\n\tonElementOutOfView: function(){},\n\tonInfiniteXInView: function(){},\n\tonInfiniteYInView: function(){}\n};\n\nvar initEvent = 'scrollwatchinit';\n\nvar extend = function(retObj) {\n\n\tvar len = arguments.length;\n\tvar i;\n\tvar key;\n\tvar obj;\n\n\tretObj = retObj || {};\n\n\tfor (i = 1; i < len; i++) {\n\n\t\tobj = arguments[i];\n\n\t\tif (!obj) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\tfor (key in obj) {\n\n\t\t\tif (obj.hasOwnProperty(key)) {\n\n\t\t\t\tretObj[key] = obj[key];\n\n\t\t\t}\n\n\t\t}\n\t}\n\n\treturn retObj;\n\n};\n\nvar throttle = function (fn, threshhold, scope) {\n\n\tthreshhold = threshhold || 250;\n\n\tvar last;\n\tvar deferTimer;\n\n\treturn function () {\n\n\t\tvar context = scope || this;\n\t\tvar now = +new Date();\n\t\tvar args = arguments;\n\n\t\tif (last && now < last + threshhold) {\n\n\t\t\twindow.clearTimeout(deferTimer);\n\n\t\t\tdeferTimer = setTimeout(function () {\n\n\t\t\t\tlast = now;\n\n\t\t\t\tfn.apply(context, args);\n\n\t\t\t}, threshhold);\n\n\t\t} else {\n\n\t\t\tlast = now;\n\n\t\t\tfn.apply(context, args);\n\n\t\t}\n\n\t};\n\n};\n\n// http://underscorejs.org/#debounce\nvar debounce = function(func, wait, immediate) {\n\n\tvar timeout;\n\tvar args;\n\tvar context;\n\tvar timestamp;\n\tvar result;\n\n\tvar later = function() {\n\n\t\tvar last = new Date().getTime() - timestamp;\n\n\t\tif (last < wait && last >= 0) {\n\n\t\t\ttimeout = setTimeout(later, wait - last);\n\n\t\t} else {\n\n\t\t\ttimeout = null;\n\n\t\t\tif (!immediate) {\n\n\t\t\t\tresult = func.apply(context, args);\n\n\t\t\t\tif (!timeout) {\n\n\t\t\t\t\tcontext = args = null;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\treturn function() {\n\n\t\tvar callNow = immediate && !timeout;\n\n\t\tcontext = this;\n\t\targs = arguments;\n\t\ttimestamp = new Date().getTime();\n\n\t\tif (!timeout) {\n\n\t\t\ttimeout = setTimeout(later, wait);\n\n\t\t}\n\n\t\tif (callNow) {\n\n\t\t\tresult = func.apply(context, args);\n\t\t\tcontext = args = null;\n\n\t\t}\n\n\t\treturn result;\n\n\t};\n\n};\n\n// Get the scrolling container element to watch if it's not the default window/documentElement.\nvar saveContainerElement = function() {\n\n\tif (!isContainerWindow.call(this)) {\n\n\t\tinstanceData[this._id].config.container = document.querySelector(instanceData[this._id].config.container);\n\n\t}\n\n};\n\n// Save all elements to watch into an array.\nvar saveElements = function() {\n\n\tinstanceData[this._id].elements = Array.prototype.slice.call(document.querySelectorAll(instanceData[this._id].config.watch + ':not(.' + ignoreClass + ')'));\n\n};\n\n// Save the scroll position of the scrolling container so we can\n// perform comparison checks.\nvar saveScrollPosition = function() {\n\n\tinstanceData[this._id].lastScrollPosition = getScrollPosition.call(this);\n\n};\n\nvar checkViewport = function(eventType) {\n\n\tcheckElements.call(this, eventType);\n\tcheckInfinite.call(this, eventType);\n\n\t// Chrome does not return 0,0 for scroll position when reloading a page\n\t// that was previously scrolled. To combat this, we will leave the scroll\n\t// position at the default 0,0 when a page is first loaded.\n\tif (eventType !== initEvent) {\n\n\t\tsaveScrollPosition.call(this);\n\n\t}\n\n};\n\n// Determine if the watched elements are viewable within the\n// scrolling container.\nvar checkElements = function(eventType) {\n\n\t// console.log('checkElements eventType: ' + eventType);\n\n\tvar data = instanceData[this._id];\n\tvar len = data.elements.length;\n\tvar config = data.config;\n\tvar inViewClass = config.inViewClass;\n\tvar responseData = {\n\t\teventType: eventType\n\t};\n\tvar el;\n\tvar i;\n\n\tfor (i = 0; i < len; i++) {\n\n\t\tel = data.elements[i];\n\n\t\t// Prepare the data to pass to the callback.\n\t\tresponseData.el = el;\n\n\t\tif (eventType === 'scroll') {\n\n\t\t\tresponseData.direction = getScrolledDirection.call(this, getScrolledAxis.call(this));\n\n\t\t}\n\n\t\tif (isElementInView.call(this, el)) {\n\n\t\t\tif (!el.classList.contains(inViewClass)) {\n\n\t\t\t\t// Add a class hook and fire a callback for every\n\t\t\t\t// element that just came into view.\n\n\t\t\t\tel.classList.add(inViewClass);\n\t\t\t\tconfig.onElementInView.call(this, responseData);\n\n\t\t\t\tif (config.watchOnce) {\n\n\t\t\t\t\t// Remove this element so we don't check it again\n\t\t\t\t\t// next time.\n\n\t\t\t\t\tdata.elements.splice(i, 1);\n\t\t\t\t\tlen--;\n\t\t\t\t\ti--;\n\n\t\t\t\t\t// Flag this element with the ignore class so we\n\t\t\t\t\t// don't store it again if a refresh happens.\n\n\t\t\t\t\tel.classList.add(ignoreClass);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif (el.classList.contains(inViewClass)) {\n\n\t\t\t\t// Remove the class hook and fire a callback for every\n\t\t\t\t// element that just went out of view.\n\n\t\t\t\tel.classList.remove(inViewClass);\n\t\t\t\tconfig.onElementOutOfView.call(this, responseData);\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n};\n\n// Determine if the infinite scroll zone is in view. This could come into\n// view by scrolling or resizing. Initial load must also be accounted\n// for.\nvar checkInfinite = function(eventType) {\n\n\tvar data = instanceData[this._id];\n\tvar config = data.config;\n\tvar i;\n\tvar axis;\n\tvar container;\n\tvar viewableRange;\n\tvar scrollSize;\n\tvar callback;\n\tvar responseData;\n\n\tif (config.infiniteScroll && !data.isInfiniteScrollPaused) {\n\n\t\taxis = ['x', 'y'];\n\t\tcallback = ['onInfiniteXInView', 'onInfiniteYInView'];\n\t\tcontainer = config.container;\n\t\tviewableRange = getViewableRange.call(this);\n\t\tscrollSize = [container.scrollWidth, container.scrollHeight];\n\t\tresponseData = {};\n\n\t\tfor (i = 0; i < 2; i++) {\n\n\t\t\t// If a scroll event triggered this check, verify the scroll\n\t\t\t// position actually changed for each axis. This stops\n\t\t\t// horizontal scrolls from triggering infiniteY callbacks\n\t\t\t// and vice versa. In other words, only trigger an infinite\n\t\t\t// callback if that axis was actually scrolled.\n\n\t\t\tif ((eventType === 'scroll' && hasScrollPositionChanged.call(this, axis[i]) || eventType === 'resize'|| eventType === 'refresh' || eventType === initEvent) && viewableRange[axis[i]].end + config.infiniteOffset >= scrollSize[i]) {\n\n\t\t\t\t// We've scrolled/resized all the way to the right/bottom.\n\n\t\t\t\tresponseData.eventType = eventType;\n\n\t\t\t\tif (eventType === 'scroll') {\n\n\t\t\t\t\tresponseData.direction = getScrolledDirection.call(this, axis[i]);\n\n\t\t\t\t}\n\n\t\t\t\tconfig[callback[i]].call(this, responseData);\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n};\n\n// Add listeners to the scrolling container for each instance.\nvar addListeners = function() {\n\n\tvar data = instanceData[this._id];\n\tvar scrollingElement = getScrollingElement.call(this);\n\n\tscrollingElement.addEventListener('scroll', data.scrollHandler, false);\n\tscrollingElement.addEventListener('resize', data.resizeHandler, false);\n\n};\n\nvar removeListeners = function() {\n\n\tvar data = instanceData[this._id];\n\tvar scrollingElement = getScrollingElement.call(this);\n\n\tscrollingElement.removeEventListener('scroll', data.scrollHandler);\n\tscrollingElement.removeEventListener('resize', data.resizeHandler);\n\n};\n\nvar getScrollingElement = function() {\n\n\treturn isContainerWindow.call(this) ? window : instanceData[this._id].config.container;\n\n};\n\n// Get the width and height of viewport/scrolling container.\nvar getViewportSize = function() {\n\n\tvar size = {\n\t\t\tw: instanceData[this._id].config.container.clientWidth,\n\t\t\th: instanceData[this._id].config.container.clientHeight\n\t\t};\n\n\treturn size;\n\n};\n\n// Get the scrollbar position of the scrolling container.\nvar getScrollPosition = function() {\n\n\tvar pos = {};\n\tvar container;\n\n\tif (isContainerWindow.call(this)) {\n\n\t\tpos.left = window.pageXOffset;\n\t\tpos.top = window.pageYOffset;\n\n\n\t} else {\n\n\t\tcontainer = instanceData[this._id].config.container;\n\n\t\tpos.left = container.scrollLeft;\n\t\tpos.top = container.scrollTop;\n\n\t}\n\n\treturn pos;\n\n};\n\n// Get the pixel range currently viewable within the\n// scrolling container.\nvar getViewableRange = function() {\n\n\tvar range = {\n\t\t\tx: {},\n\t\t\ty: {}\n\t\t};\n\tvar scrollPos = getScrollPosition.call(this);\n\tvar viewportSize = getViewportSize.call(this);\n\n\trange.x.start = scrollPos.left;\n\trange.x.end =  range.x.start + viewportSize.w;\n\trange.x.size = range.x.end - range.x.start;\n\n\trange.y.start = scrollPos.top;\n\trange.y.end = range.y.start + viewportSize.h;\n\trange.y.size = range.y.end - range.y.start;\n\n\treturn range;\n\n};\n\n// Get the pixel range of where this element falls within the\n// scrolling container.\nvar getElementRange = function(el) {\n\n\tvar range = {\n\t\t\tx: {},\n\t\t\ty: {}\n\t\t};\n\tvar viewableRange = getViewableRange.call(this);\n\tvar coords = el.getBoundingClientRect();\n\tvar containerCoords;\n\n\tif (isContainerWindow.call(this)) {\n\n\t\trange.x.start = coords.left + viewableRange.x.start;\n\t\trange.x.end = coords.right + viewableRange.x.start;\n\n\n\t\trange.y.start = coords.top + viewableRange.y.start;\n\t\trange.y.end = coords.bottom + viewableRange.y.start;\n\n\t} else {\n\n\t\tcontainerCoords = instanceData[this._id].config.container.getBoundingClientRect();\n\n\t\trange.x.start = (coords.left - containerCoords.left) + viewableRange.x.start;\n\t\trange.x.end = range.x.start + coords.width;\n\n\t\trange.y.start = (coords.top - containerCoords.top) + viewableRange.y.start;\n\t\trange.y.end = range.y.start + coords.height;\n\n\t}\n\n\trange.x.size = range.x.end - range.x.start;\n\trange.y.size = range.y.end - range.y.start;\n\n\treturn range;\n\n};\n\n// Determines which axis was just scrolled (x/horizontal or y/vertical).\nvar getScrolledAxis = function() {\n\n\tif (hasScrollPositionChanged.call(this, 'x')) {\n\n\t\treturn 'x';\n\n\t}\n\n\tif (hasScrollPositionChanged.call(this, 'y')) {\n\n\t\treturn 'y';\n\n\t}\n\n};\n\nvar getScrolledDirection = function(axis) {\n\n\tvar scrollDir = {x: ['right', 'left'], y: ['down', 'up']};\n\tvar position = {x: 'left', y: 'top'};\n\tvar lastScrollPosition = instanceData[this._id].lastScrollPosition;\n\tvar curScrollPosition = getScrollPosition.call(this);\n\n\treturn curScrollPosition[position[axis]] > lastScrollPosition[position[axis]] ? scrollDir[axis][0] : scrollDir[axis][1];\n\n};\n\nvar hasScrollPositionChanged = function(axis) {\n\n\tvar position = {x: 'left', y: 'top'};\n\tvar lastScrollPosition = instanceData[this._id].lastScrollPosition;\n\tvar curScrollPosition = getScrollPosition.call(this);\n\n\treturn curScrollPosition[position[axis]] !== lastScrollPosition[position[axis]];\n\n};\n\nvar isElementInView = function(el) {\n\n\tvar viewableRange = getViewableRange.call(this);\n\tvar elRange = getElementRange.call(this, el);\n\tvar offset = instanceData[this._id].config.watchOffset;\n\n\treturn isElementInVerticalView(elRange, viewableRange, offset) && isElementInHorizontalView(elRange, viewableRange, offset);\n\n};\n\nvar isElementInVerticalView = function(elRange, viewableRange, offset) {\n\n\treturn elRange.y.start < viewableRange.y.end + offset && elRange.y.end > viewableRange.y.start - offset;\n\n};\n\nvar isElementInHorizontalView = function(elRange, viewableRange, offset) {\n\n\treturn elRange.x.start < viewableRange.x.end + offset && elRange.x.end > viewableRange.x.start - offset;\n\n};\n\nvar isContainerWindow = function() {\n\n\treturn instanceData[this._id].config.container === window.document.documentElement;\n\n};\n\nvar mergeOptions = function(opts) {\n\n\textend(instanceData[this._id].config, config, opts);\n\n};\n\nvar handler = function(e) {\n\n\tvar eventType = e.type;\n\n\t// For scroll events, only check the viewport if something\n\t// has changed. Fixes issues when using gestures on a page\n\t// that doesn't need to scroll. An event would still fire,\n\t// but the position didn't change  because the\n\t// window/container \"bounced\" back into place.\n\tif (eventType === 'resize' || hasScrollPositionChanged.call(this, 'x') || hasScrollPositionChanged.call(this, 'y')) {\n\n\t\tcheckViewport.call(this, eventType);\n\n\t}\n\n};\n\nvar ScrollWatch = function(opts) {\n\n\t// Protect against missing new keyword.\n\tif (this instanceof ScrollWatch) {\n\n\t\tvar data;\n\n\t\tObject.defineProperty(this, '_id', {value: instanceId++});\n\n\t\t// Keep all instance data private, except for the '_id', which will\n\t\t// be the key to get the private data for a specific instance.\n\n\t\tdata = instanceData[this._id] = {\n\n\t\t\tconfig: {},\n\t\t\t// The elements to watch for this instance.\n\t\t\telements: [],\n\t\t\tlastScrollPosition: {top: 0, left: 0},\n\t\t\tisInfiniteScrollPaused: false\n\n\t\t};\n\n\t\tmergeOptions.call(this, opts);\n\n\t\t// In order to remove listeners later and keep a correct reference\n\t\t// to 'this', give each instance it's own event handler.\n\t\tif (data.config.debounce) {\n\n\t\t\tdata.scrollHandler = debounce(handler.bind(this), data.config.scrollDebounce, data.config.debounceTriggerLeading);\n\t\t\tdata.resizeHandler = debounce(handler.bind(this), data.config.resizeDebounce, data.config.debounceTriggerLeading);\n\n\t\t} else {\n\n\t\t\tdata.scrollHandler = throttle(handler.bind(this), data.config.scrollThrottle, this);\n\t\t\tdata.resizeHandler = throttle(handler.bind(this), data.config.resizeThrottle, this);\n\n\t\t}\n\n\t\tsaveContainerElement.call(this);\n\t\taddListeners.call(this);\n\t\tsaveElements.call(this);\n\t\tcheckViewport.call(this, initEvent);\n\n\t} else {\n\n\t\treturn new ScrollWatch(opts);\n\n\t}\n\n};\n\nScrollWatch.prototype = {\n\n\t// Should be manually called by user after loading in new content.\n\trefresh: function() {\n\n\t\tsaveElements.call(this);\n\t\tcheckViewport.call(this, 'refresh');\n\n\t},\n\n\tdestroy: function() {\n\n\t\tremoveListeners.call(this);\n\t\tdelete instanceData[this._id];\n\n\t},\n\n\tpauseInfiniteScroll: function() {\n\n\t\tinstanceData[this._id].isInfiniteScrollPaused = true;\n\n\t},\n\n\tresumeInfiniteScroll: function() {\n\n\t\tinstanceData[this._id].isInfiniteScrollPaused = false;\n\n\t}\n\n};\n\nreturn ScrollWatch;\n}));\n"],"sourceRoot":"/source/"}